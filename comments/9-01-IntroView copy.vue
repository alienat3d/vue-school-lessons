<!-- * 9.0 Как альтернатива "ref" есть также "reactive", который используют для типов данных вроде массивов и объектов. -->
<script setup>
import { reactive } from 'vue'

// 9.1 Например создадим переменную "state", которой присвоим функцию reactive, у которой внутри будет объект.
let state = reactive({ count: 0 })

// const increment = () => state.count++

// 9.3 А в-третьих, значение "reactive" не так просто заменить, представим, что у нас метод, который увеличивает счётчик на 1 не прямо, а переменной state будет присвоен новый объект и значению его свойства "count" будет присвоена функция инкремента. И вот он уже не работает. Хоть в нашем случае полная перезапись стейта переменной в нашем случае не имеет большого значения, но есть другие случаи, где нам бы хотелось мочь это сделать.
// ? 9.4 Некоторые люди используют ref’ы вообще везде, даже на их массивах и объектах и так они привыкают использовать ".value" в секции "script" постоянно. Но какого-то правила здесь нет и на усмотрение программиста.
const increment = () => {
  state = {
    count: state.count++,
  }
}
</script>

<!-- ? 9.5 Почему же нам не нужно писать ".value" в тэмплэйте? Потому, что Vue использует там такую фичу, как "автоматическая распаковка", делая это за нас. -->
<template>
  <div>
    <h1>Getting Started with Vue.js and the Composition API</h1>
    <!-- 9.2 И пока это не выглядит чем-то отличным от ref'ов, но есть и некоторые отличия. Во-первых, мы не используем .value, когда пишем в секции "script". Во-вторых, "reactive" не работает с примитивными типами данных. -->
    <p>{{ state.count }}</p>
    <button @click="increment" class="btn btn-primary">Increment Count</button>
  </div>
</template>

<style></style>
